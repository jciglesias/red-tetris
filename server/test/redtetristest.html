<!DOCTYPE html>
<html>
<head>
    <title>Red Tetris Test Client</title>
    <script src="https://cdn.socket.io/4.7.4/socket.io.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        .container {
            display: flex;
            gap: 20px;
        }
        .controls {
            flex: 1;
        }
        .players-area {
            flex: 2;
            display: flex;
            gap: 20px;
        }
        .player-area {
            flex: 1;
            background: linear-gradient(145deg, #fafafa, #f0f0f0);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            border: 1px solid #ddd;
        }
        .player-area h3 {
            margin-top: 0;
            color: #333;
            text-align: center;
            padding: 10px;
            background: linear-gradient(145deg, #e3f2fd, #bbdefb);
            border-radius: 8px;
            border: 1px solid #90caf9;
        }
        .player-area h4 {
            color: #555;
            margin: 15px 0 8px 0;
            padding: 5px 0;
            border-bottom: 2px solid #ddd;
        }
        .player-selector {
            margin: 10px 0;
            padding: 10px;
            background-color: #e3f2fd;
            border-radius: 4px;
        }
        .tetris-board {
            display: grid;
            grid-template-columns: repeat(10, 25px);
            grid-template-rows: repeat(20, 25px);
            gap: 1px;
            border: 3px solid #333;
            background-color: #222;
            margin: 10px 0;
            padding: 5px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        .tetris-cell {
            width: 25px;
            height: 25px;
            border: 1px solid #444;
            background-color: #111;
            transition: all 0.1s ease;
        }
        .tetris-cell.filled {
            background: linear-gradient(145deg, #4CAF50, #45a049);
            border: 1px solid #66BB6A;
            box-shadow: inset 1px 1px 2px rgba(255,255,255,0.3);
        }
        .tetris-cell.current {
            background: linear-gradient(145deg, #FF9800, #F57C00);
            border: 1px solid #FFB74D;
            box-shadow: inset 1px 1px 2px rgba(255,255,255,0.3);
            animation: pulse 0.5s ease-in-out infinite alternate;
        }
        .tetris-cell.ghost {
            background-color: rgba(255, 152, 0, 0.3);
            border: 1px dashed #FF9800;
        }
        .tetris-cell.line-clear {
            background: linear-gradient(45deg, #FFD700, #FFA000);
            animation: line-clear 0.5s ease-in-out;
        }
        @keyframes pulse {
            from { opacity: 0.7; }
            to { opacity: 1; }
        }
        @keyframes line-clear {
            0% { background: linear-gradient(45deg, #FFD700, #FFA000); }
            50% { background: linear-gradient(45deg, #FFEB3B, #FF6F00); }
            100% { background: linear-gradient(45deg, #FFD700, #FFA000); }
        }
        .next-piece {
            display: grid;
            grid-template-columns: repeat(4, 20px);
            grid-template-rows: repeat(4, 20px);
            gap: 1px;
            border: 2px solid #333;
            background-color: #222;
            margin: 10px 0;
            padding: 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .next-cell {
            width: 20px;
            height: 20px;
            border: 1px solid #444;
            background-color: #111;
        }
        .next-cell.filled {
            background: linear-gradient(145deg, #2196F3, #1976D2);
            border: 1px solid #42A5F5;
            box-shadow: inset 1px 1px 2px rgba(255,255,255,0.3);
        }
        .game-info {
            margin: 10px 0;
            padding: 12px;
            background: linear-gradient(145deg, #f5f5f5, #e8e8e8);
            border-radius: 8px;
            font-size: 14px;
            font-weight: bold;
            border: 1px solid #ddd;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .game-info div {
            margin: 4px 0;
            padding: 2px 0;
        }
        .game-info span {
            color: #1976D2;
            font-weight: normal;
        }
        #messages {
            height: 250px;
            overflow-y: scroll;
            border: 2px solid #ccc;
            padding: 10px;
            font-size: 11px;
            background-color: #fafafa;
            font-family: 'Courier New', monospace;
            border-radius: 4px;
        }
        #messages div {
            margin: 2px 0;
            padding: 2px 0;
            border-bottom: 1px dotted #eee;
        }
        #messages strong {
            color: #666;
        }
        .player-controls {
            margin: 15px 0;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
            max-width: 200px;
        }
        .player-controls button {
            margin: 2px;
            padding: 8px 12px;
            font-size: 16px;
            font-weight: bold;
            border: 2px solid #333;
            border-radius: 6px;
            background: linear-gradient(145deg, #f0f0f0, #ddd);
            cursor: pointer;
            transition: all 0.1s ease;
            min-height: 40px;
        }
        .player-controls button:hover {
            background: linear-gradient(145deg, #e0e0e0, #ccc);
            transform: translateY(-1px);
        }
        .player-controls button:active {
            transform: translateY(1px);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
        }
        .player-controls button:nth-child(1) { grid-column: 1; grid-row: 2; } /* Left */
        .player-controls button:nth-child(2) { grid-column: 3; grid-row: 2; } /* Right */
        .player-controls button:nth-child(3) { grid-column: 2; grid-row: 1; } /* Rotate */
        .player-controls button:nth-child(4) { grid-column: 2; grid-row: 2; } /* Soft Drop */
        .player-controls button:nth-child(5) { grid-column: 2; grid-row: 3; } /* Hard Drop */
        .active-player {
            background-color: #c8e6c9 !important;
        }
        .player-connection {
            margin: 10px 0;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #f9f9f9;
        }
        .player-connection.connected {
            background-color: #e8f5e8;
            border-color: #4CAF50;
        }
        .player-connection input {
            margin: 5px;
            padding: 5px;
            font-size: 12px;
        }
        .player-connection button {
            margin: 2px;
            padding: 8px 12px;
            font-size: 12px;
            border-radius: 4px;
            border: 1px solid #ccc;
            background: linear-gradient(145deg, #f8f8f8, #e8e8e8);
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .player-connection button:hover {
            background: linear-gradient(145deg, #e8e8e8, #d8d8d8);
            transform: translateY(-1px);
        }
        /* Different colors for Tetris pieces */
        .tetris-cell.piece-I { background: linear-gradient(145deg, #00BCD4, #0097A7); border-color: #26C6DA; } /* Cyan */
        .tetris-cell.piece-O { background: linear-gradient(145deg, #FFEB3B, #F57F17); border-color: #FFEE58; } /* Yellow */
        .tetris-cell.piece-T { background: linear-gradient(145deg, #9C27B0, #7B1FA2); border-color: #BA68C8; } /* Purple */
        .tetris-cell.piece-S { background: linear-gradient(145deg, #4CAF50, #388E3C); border-color: #66BB6A; } /* Green */
        .tetris-cell.piece-Z { background: linear-gradient(145deg, #F44336, #D32F2F); border-color: #EF5350; } /* Red */
        .tetris-cell.piece-J { background: linear-gradient(145deg, #2196F3, #1976D2); border-color: #42A5F5; } /* Blue */
        .tetris-cell.piece-L { background: linear-gradient(145deg, #FF9800, #F57C00); border-color: #FFB74D; } /* Orange */
        .tetris-cell.piece-penalty { background: linear-gradient(145deg, #424242, #212121); border-color: #616161; } /* Dark Gray - Penalty blocks */
        
        /* Game status indicators */
        .status-playing { color: #4CAF50; font-weight: bold; }
        .status-paused { color: #FF9800; font-weight: bold; }
        .status-game-over { color: #F44336; font-weight: bold; }
        .status-waiting { color: #2196F3; font-weight: bold; }
    </style>
</head>
<body>
    <h1>Red Tetris Test Client</h1>
    
    <div class="container">
        <div class="controls">
            <div>
                <h3>Global Actions</h3>
                <button onclick="sendHeartbeat()">Send Heartbeat</button>
                <div style="margin: 10px 0; padding: 8px; background-color: #e3f2fd; border-radius: 4px; font-size: 11px;">
                    <strong>Keyboard Controls (Player 1):</strong><br>
                    ← → ↑ ↓ Arrow keys for movement/rotation<br>
                    <strong>Space</strong> for hard drop
                </div>
            </div>

            <div>
                <h3>Messages</h3>
                <div id="messages"></div>
            </div>
        </div>

        <div class="players-area">
            <div class="player-area">
                <h3>Player 1</h3>
                
                <div id="player1Connection" class="player-connection">
                    <h4>Connection</h4>
                    <button onclick="connectPlayer(1)">Connect</button>
                    <button onclick="disconnectPlayer(1)">Disconnect</button>
                    <p>Status: <span id="connectionStatus1">Disconnected</span></p>
                    
                    <h4>Join Room</h4>
                    <input type="text" id="roomName1" placeholder="Room name" value="test-room">
                    <input type="text" id="playerName1" placeholder="Player name" value="player1">
                    <button onclick="joinRoom(1)">Join Room</button>
                    <button onclick="setReady(1)">Toggle Ready</button>
                    <button onclick="startGame()">Start Game</button>
                    
                    <h4>Reconnection</h4>
                    <input type="text" id="reconnectionToken1" placeholder="Reconnection token">
                    <button onclick="requestReconnection(1)">Reconnect</button>
                </div>

                <div class="game-info">
                    <div>Score: <span id="score1">0</span></div>
                    <div>Level: <span id="level1">1</span></div>
                    <div>Lines: <span id="lines1">0</span></div>
                    <div>Status: <span id="status1">Not Connected</span></div>
                </div>
                <div id="tetrisBoard1" class="tetris-board"></div>
                
                <h4>Next Piece</h4>
                <div id="nextPiece1" class="next-piece"></div>
                
                <div class="player-controls">
                    <button onclick="sendPlayerAction(1, 'move-left')">←</button>
                    <button onclick="sendPlayerAction(1, 'move-right')">→</button>
                    <button onclick="sendPlayerAction(1, 'rotate')">↻</button>
                    <button onclick="sendPlayerAction(1, 'soft-drop')">↓</button>
                    <button onclick="sendPlayerAction(1, 'hard-drop')">⇓</button>
                </div>
            </div>

            <div class="player-area">
                <h3>Player 2</h3>
                
                <div id="player2Connection" class="player-connection">
                    <h4>Connection</h4>
                    <button onclick="connectPlayer(2)">Connect</button>
                    <button onclick="disconnectPlayer(2)">Disconnect</button>
                    <p>Status: <span id="connectionStatus2">Disconnected</span></p>
                    
                    <h4>Join Room</h4>
                    <input type="text" id="roomName2" placeholder="Room name" value="test-room">
                    <input type="text" id="playerName2" placeholder="Player name" value="player2">
                    <button onclick="joinRoom(2)">Join Room</button>
                    <button onclick="setReady(2)">Toggle Ready</button>
                    
                    <h4>Reconnection</h4>
                    <input type="text" id="reconnectionToken2" placeholder="Reconnection token">
                    <button onclick="requestReconnection(2)">Reconnect</button>
                </div>

                <div class="game-info">
                    <div>Score: <span id="score2">0</span></div>
                    <div>Level: <span id="level2">1</span></div>
                    <div>Lines: <span id="lines2">0</span></div>
                    <div>Status: <span id="status2">Not Connected</span></div>
                </div>
                <div id="tetrisBoard2" class="tetris-board"></div>
                
                <h4>Next Piece</h4>
                <div id="nextPiece2" class="next-piece"></div>
                
                <div class="player-controls">
                    <button onclick="sendPlayerAction(2, 'move-left')">←</button>
                    <button onclick="sendPlayerAction(2, 'move-right')">→</button>
                    <button onclick="sendPlayerAction(2, 'rotate')">↻</button>
                    <button onclick="sendPlayerAction(2, 'soft-drop')">↓</button>
                    <button onclick="sendPlayerAction(2, 'hard-drop')">⇓</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        let sockets = { 1: null, 2: null };
        let playersReady = { 1: false, 2: false };
        let currentGameStates = { 1: null, 2: null };

        // Initialize empty board for a specific player
        function initializeBoard(playerId) {
            const board = document.getElementById(`tetrisBoard${playerId}`);
            board.innerHTML = '';
            for (let row = 0; row < 20; row++) {
                for (let col = 0; col < 10; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'tetris-cell';
                    cell.id = `cell-${playerId}-${row}-${col}`;
                    board.appendChild(cell);
                }
            }
        }

        // Initialize next piece area for a specific player
        function initializeNextPiece(playerId) {
            const nextPiece = document.getElementById(`nextPiece${playerId}`);
            nextPiece.innerHTML = '';
            for (let row = 0; row < 4; row++) {
                for (let col = 0; col < 4; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'next-cell';
                    cell.id = `next-${playerId}-${row}-${col}`;
                    nextPiece.appendChild(cell);
                }
            }
        }

        // Render the game board for a specific player
        function renderBoard(playerId, gameState) {
            console.log('=== RENDERING BOARD ===');
            console.log('Player ID:', playerId);
            console.log('Game State:', gameState);
            
            // Clear all cells first
            for (let row = 0; row < 20; row++) {
                for (let col = 0; col < 10; col++) {
                    const cell = document.getElementById(`cell-${playerId}-${row}-${col}`);
                    if (cell) {
                        cell.className = 'tetris-cell';
                    }
                }
            }

            if (!gameState) {
                console.log('No game state provided');
                return;
            }

            // Render fixed pieces (board state) with piece types
            if (gameState.board && Array.isArray(gameState.board)) {
                console.log('Rendering board matrix. Size:', gameState.board.length, 'x', gameState.board[0]?.length);
                console.log('Board data:', gameState.board);
                
                for (let row = 0; row < Math.min(gameState.board.length, 20); row++) {
                    for (let col = 0; col < Math.min(gameState.board[row].length, 10); col++) {
                        const cellValue = gameState.board[row][col];
                        if (cellValue !== 0) {
                            const cell = document.getElementById(`cell-${playerId}-${row}-${col}`);
                            if (cell) {
                                // Map numeric values to piece types (1-7 -> I,O,T,S,Z,J,L, 9 -> penalty)
                                const pieceTypes = ['', 'I', 'O', 'T', 'S', 'Z', 'J', 'L', '', 'penalty'];
                                const pieceType = pieceTypes[cellValue] || '';
                                if (pieceType) {
                                    cell.className = `tetris-cell filled piece-${pieceType}`;
                                    console.log(`Set cell [${row},${col}] to piece-${pieceType}`);
                                } else {
                                    cell.className = 'tetris-cell filled';
                                    console.log(`Set cell [${row},${col}] to filled (unknown type: ${cellValue})`);
                                }
                            }
                        }
                    }
                }
            } else {
                console.log('No valid board data found');
            }

            // Render current piece
            if (gameState.currentPiece && gameState.currentPiece.shape) {
                console.log('Rendering current piece:', gameState.currentPiece);
                const piece = gameState.currentPiece;
                const pieceX = piece.x !== undefined ? piece.x : 0;
                const pieceY = piece.y !== undefined ? piece.y : 0;
                
                console.log(`Current piece position: (${pieceX}, ${pieceY})`);
                console.log('Current piece shape:', piece.shape);
                
                for (let row = 0; row < piece.shape.length; row++) {
                    for (let col = 0; col < piece.shape[row].length; col++) {
                        if (piece.shape[row][col]) {
                            const boardRow = pieceY + row;
                            const boardCol = pieceX + col;
                            console.log(`Trying to place piece cell at board position: (${boardCol}, ${boardRow})`);
                            
                            if (boardRow >= 0 && boardRow < 20 && boardCol >= 0 && boardCol < 10) {
                                const cell = document.getElementById(`cell-${playerId}-${boardRow}-${boardCol}`);
                                if (cell && !cell.classList.contains('filled')) {
                                    const pieceType = piece.type || '';
                                    if (pieceType) {
                                        cell.className = `tetris-cell current piece-${pieceType}`;
                                        console.log(`Set current piece cell [${boardRow},${boardCol}] to piece-${pieceType}`);
                                    } else {
                                        cell.className = 'tetris-cell current';
                                        console.log(`Set current piece cell [${boardRow},${boardCol}] to current (no type)`);
                                    }
                                }
                            } else {
                                console.log(`Piece cell out of bounds: (${boardCol}, ${boardRow})`);
                            }
                        }
                    }
                }
            } else {
                console.log('No current piece to render');
            }
            
            console.log('=== BOARD RENDERING COMPLETE ===');
        }

        // Render next piece for a specific player
        function renderNextPiece(playerId, nextPiece) {
            console.log('=== RENDERING NEXT PIECE ===');
            console.log('Player ID:', playerId);
            console.log('Next piece:', nextPiece);
            
            // Clear next piece area
            for (let row = 0; row < 4; row++) {
                for (let col = 0; col < 4; col++) {
                    const cell = document.getElementById(`next-${playerId}-${row}-${col}`);
                    if (cell) {
                        cell.className = 'next-cell';
                    }
                }
            }

            // Render next piece if available
            if (nextPiece && nextPiece.shape && Array.isArray(nextPiece.shape)) {
                console.log('Rendering next piece shape:', nextPiece.shape);
                for (let row = 0; row < nextPiece.shape.length; row++) {
                    for (let col = 0; col < nextPiece.shape[row].length; col++) {
                        if (nextPiece.shape[row][col]) {
                            const cell = document.getElementById(`next-${playerId}-${row}-${col}`);
                            if (cell) {
                                const pieceType = nextPiece.type;
                                cell.className = `next-cell filled${pieceType ? ' piece-' + pieceType : ''}`;
                                console.log(`Set next piece cell [${row},${col}] to piece-${pieceType}`);
                            }
                        }
                    }
                }
            } else {
                console.log('No valid next piece to render');
            }
            
            console.log('=== NEXT PIECE RENDERING COMPLETE ===');
        }

        // Helper function to extract player-specific game state
        function extractPlayerGameState(gameStateData, playerId) {
            const playerName = document.getElementById(`playerName${playerId}`).value;
            
            console.log('=== EXTRACTING PLAYER STATE ===');
            console.log('Player ID:', playerId, 'Player Name:', playerName);
            console.log('Full game state data:', gameStateData);
            
            if (!gameStateData) {
                console.log('No game state data found');
                return null;
            }
            
            if (!gameStateData.players) {
                console.log('No players data found in game state');
                return null;
            }
            
            console.log('Players structure:', gameStateData.players);
            console.log('Players type:', typeof gameStateData.players);
            console.log('Players keys:', Object.keys(gameStateData.players));
            
            // Try direct access by player name (this should be the main case)
            let playerState = gameStateData.players[playerName];
            
            if (playerState) {
                console.log('✓ Found by player name:', playerName, '=', playerState);
                return playerState;
            }
            
            // Try compound key (roomName_playerName)
            const roomName = document.getElementById(`roomName${playerId}`).value;
            const compoundKey = `${roomName}_${playerName}`;
            console.log('Trying compound key:', compoundKey);
            playerState = gameStateData.players[compoundKey];
            if (playerState) {
                console.log('✓ Found by compound key:', compoundKey, '=', playerState);
                return playerState;
            }
            
            // If not found, try searching through all players
            console.log('Player not found by name or compound key, searching all players...');
            for (const [key, value] of Object.entries(gameStateData.players)) {
                console.log(`Checking player key: "${key}", value:`, value);
                if (value && (
                    value.playerId === compoundKey ||
                    value.playerId === playerName ||
                    key === playerName ||
                    key.endsWith(`_${playerName}`) ||
                    value.playerName === playerName ||
                    value.name === playerName ||
                    key === playerId.toString()
                )) {
                    console.log('✓ Found by search:', key, '=', value);
                    return value;
                }
            }
            
            console.log('❌ No player state found for:', playerName);
            return null;
        }

        // Update game info for a specific player
        function updateGameInfo(playerId, playerGameState) {
            if (playerGameState.score !== undefined) {
                document.getElementById(`score${playerId}`).textContent = playerGameState.score || 0;
            }
            if (playerGameState.level !== undefined) {
                document.getElementById(`level${playerId}`).textContent = playerGameState.level || 1;
            }
            if (playerGameState.lines !== undefined) {
                document.getElementById(`lines${playerId}`).textContent = playerGameState.lines;
            }
            
            // Update status based on game state
            const statusElement = document.getElementById(`status${playerId}`);
            if (playerGameState.isAlive !== undefined) {
                if (playerGameState.isAlive) {
                    statusElement.textContent = 'Playing';
                    statusElement.className = 'status-playing';
                } else {
                    statusElement.textContent = 'Game Over';
                    statusElement.className = 'status-game-over';
                }
            }
        }

        // Connect specific player
        function connectPlayer(playerId) {
            if (sockets[playerId]) {
                addMessage(`Player ${playerId} already connected`);
                return;
            }

            sockets[playerId] = io('http://localhost:3001');
            const socket = sockets[playerId];
            
            socket.on('connect', () => {
                document.getElementById(`connectionStatus${playerId}`).textContent = 'Connected';
                document.getElementById(`player${playerId}Connection`).classList.add('connected');
                addMessage(`Player ${playerId} connected to server`);
            });

            socket.on('disconnect', () => {
                document.getElementById(`connectionStatus${playerId}`).textContent = 'Disconnected';
                document.getElementById(`player${playerId}Connection`).classList.remove('connected');
                addMessage(`Player ${playerId} disconnected from server`);
            });

            // Room events
            socket.on('join-room-success', (data) => {
                addMessage(`Player ${playerId} join room success`);
                console.log('Join room success data:', data);
                document.getElementById(`status${playerId}`).textContent = 'In Room';
                
                // Check if there's an ongoing game state (for reconnections)
                if (data.gameState) {
                    const playerGameState = extractPlayerGameState(data.gameState, playerId);
                    
                    if (playerGameState) {
                        console.log('Found ongoing game state on join:', playerGameState);
                        currentGameStates[playerId] = playerGameState;
                        renderBoard(playerId, playerGameState);
                        updateGameInfo(playerId, playerGameState);
                        if (playerGameState.nextPieces && playerGameState.nextPieces[0]) {
                            renderNextPiece(playerId, playerGameState.nextPieces[0]);
                        }
                        document.getElementById(`status${playerId}`).textContent = 'Playing';
                    }
                }
            });

            socket.on('join-room-error', (data) => {
                addMessage(`Player ${playerId} join room error: ` + JSON.stringify(data, null, 2));
            });

            socket.on('player-joined', (data) => {
                addMessage(`Player ${playerId} sees player joined: ` + JSON.stringify(data, null, 2));
            });

            socket.on('player-left', (data) => {
                addMessage(`Player ${playerId} sees player left: ` + JSON.stringify(data, null, 2));
            });

            socket.on('player-ready-changed', (data) => {
                addMessage(`Player ${playerId} sees ready changed: ` + JSON.stringify(data, null, 2));
                
                // Update local ready state if this is our player
                const playerName = document.getElementById(`playerName${playerId}`).value;
                console.log('Ready changed - checking for player:', playerName, 'in data:', data);
                
                // The server sends playerId which should be the player.id (likely the player name)
                if (data.playerId === playerName) {
                    playersReady[playerId] = data.ready;
                    addMessage(`Player ${playerId} ready state updated to: ${data.ready}`);
                } else {
                    console.log('Ready change not for this player:', data.playerId, 'vs', playerName);
                }
            });

            // Game events
            socket.on('game-started', (data) => {
                addMessage(`Player ${playerId} game started`);
                console.log('Game started data:', data);
                
                // Extract this player's game state
                const playerGameState = extractPlayerGameState(data.gameState, playerId);
                
                if (playerGameState) {
                    console.log('Player game state found:', playerGameState);
                    currentGameStates[playerId] = playerGameState;
                    renderBoard(playerId, playerGameState);
                    updateGameInfo(playerId, playerGameState);
                    if (playerGameState.nextPieces && playerGameState.nextPieces[0]) {
                        renderNextPiece(playerId, playerGameState.nextPieces[0]);
                    }
                } else {
                    console.log('No player game state found in game-started');
                }
                document.getElementById(`status${playerId}`).textContent = 'Playing';
            });

            socket.on('game-state-update', (data) => {
                addMessage(`Player ${playerId} game state update received`);
                console.log('Game state update:', data);
                
                // Extract this player's game state
                const playerGameState = extractPlayerGameState(data, playerId);
                
                if (playerGameState) {
                    console.log('Player game state found in update:', playerGameState);
                    currentGameStates[playerId] = playerGameState;
                    renderBoard(playerId, playerGameState);
                    updateGameInfo(playerId, playerGameState);
                    if (playerGameState.nextPieces && playerGameState.nextPieces[0]) {
                        renderNextPiece(playerId, playerGameState.nextPieces[0]);
                    }
                } else {
                    console.log('No player game state found in update');
                }
            });

            socket.on('game-ended', (data) => {
                addMessage(`Player ${playerId} game ended: ` + JSON.stringify(data, null, 2));
                document.getElementById(`status${playerId}`).textContent = 'Game Over';
            });

            socket.on('game-paused', (data) => {
                addMessage(`Player ${playerId} game paused: ` + JSON.stringify(data, null, 2));
            });

            socket.on('game-reset', (data) => {
                addMessage(`Player ${playerId} game reset: ` + JSON.stringify(data, null, 2));
            });

            // Reconnection events
            socket.on('reconnection-success', (data) => {
                addMessage(`Player ${playerId} reconnection success: ` + JSON.stringify(data, null, 2));
            });

            socket.on('reconnection-error', (data) => {
                addMessage(`Player ${playerId} reconnection error: ` + JSON.stringify(data, null, 2));
            });

            socket.on('heartbeat-ack', () => {
                addMessage(`Player ${playerId} heartbeat acknowledged`);
            });

            // Error events
            socket.on('error', (data) => {
                addMessage(`Player ${playerId} error: ` + JSON.stringify(data, null, 2));
            });
        }

        // Disconnect specific player
        function disconnectPlayer(playerId) {
            if (sockets[playerId]) {
                sockets[playerId].disconnect();
                sockets[playerId] = null;
                playersReady[playerId] = false;
                document.getElementById(`status${playerId}`).textContent = 'Not Connected';
            }
        }

        // Join room for specific player
        function joinRoom(playerId) {
            if (!sockets[playerId]) {
                addMessage(`Player ${playerId} not connected`);
                return;
            }

            const roomName = document.getElementById(`roomName${playerId}`).value;
            const playerName = document.getElementById(`playerName${playerId}`).value;

            sockets[playerId].emit('join-room', {
                roomName,
                playerName
            });
        }

        // Set ready for specific player
        function setReady(playerId) {
            if (!sockets[playerId]) {
                addMessage(`Player ${playerId} not connected`);
                return;
            }

            // Toggle the ready state and send to server
            const newReadyState = !playersReady[playerId];
            console.log()
            sockets[playerId].emit('player-ready', { ready: newReadyState });
            addMessage(`Player ${playerId} sent ready toggle event: ${newReadyState}`);
        }

        // Send action for specific player
        function sendPlayerAction(playerId, action) {
            if (!sockets[playerId]) {
                addMessage(`Player ${playerId} not connected`);
                return;
            }

            sockets[playerId].emit('game-action', { action });
            addMessage(`Player ${playerId} sent action: ${action}`);
        }

        // Request reconnection for specific player
        function requestReconnection(playerId) {
            if (!sockets[playerId]) {
                addMessage(`Player ${playerId} not connected`);
                return;
            }

            const roomName = document.getElementById(`roomName${playerId}`).value;
            const playerName = document.getElementById(`playerName${playerId}`).value;
            const reconnectionToken = document.getElementById(`reconnectionToken${playerId}`).value;

            sockets[playerId].emit('request-reconnection', {
                roomName,
                playerName,
                reconnectionToken: reconnectionToken || undefined
            });
        }

        // Start game (only from Player 1)
        function startGame() {
            if (!sockets[1]) {
                addMessage('Player 1 not connected');
                return;
            }

            sockets[1].emit('start-game');
            addMessage('Start game requested by Player 1');
        }

        // Send heartbeat (can be called from either connected player)
        function sendHeartbeat() {
            const connectedSocket = sockets[1] || sockets[2];
            if (!connectedSocket) {
                addMessage('No players connected');
                return;
            }

            connectedSocket.emit('heartbeat');
        }

        // Legacy functions for compatibility
        function connect() {
            connectPlayer(1);
        }

        function disconnect() {
            disconnectPlayer(1);
            disconnectPlayer(2);
        }

        function sendAction(action) {
            // Send action for both connected players
            [1, 2].forEach(playerId => {
                if (sockets[playerId]) {
                    sendPlayerAction(playerId, action);
                }
            });
        }

        // Initialize boards on page load
        window.onload = function() {
            initializeBoard(1);
            initializeBoard(2);
            initializeNextPiece(1);
            initializeNextPiece(2);
            
            // Add keyboard controls for Player 1
            document.addEventListener('keydown', function(event) {
                if (!sockets[1]) return;
                
                switch(event.key) {
                    case 'ArrowLeft':
                        event.preventDefault();
                        sendPlayerAction(1, 'move-left');
                        break;
                    case 'ArrowRight':
                        event.preventDefault();
                        sendPlayerAction(1, 'move-right');
                        break;
                    case 'ArrowUp':
                        event.preventDefault();
                        sendPlayerAction(1, 'rotate');
                        break;
                    case 'ArrowDown':
                        event.preventDefault();
                        sendPlayerAction(1, 'soft-drop');
                        break;
                    case ' ':
                        event.preventDefault();
                        sendPlayerAction(1, 'hard-drop');
                        break;
                }
            });
        };

        function addMessage(message) {
            const messagesDiv = document.getElementById('messages');
            const timestamp = new Date().toLocaleTimeString();
            messagesDiv.innerHTML += `<div><strong>[${timestamp}]</strong> ${message}</div>`;
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }
    </script>
</body>
</html>
</html>
